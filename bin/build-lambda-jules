#!/bin/bash
# -----------------------------------------------------------------------------
# (C) Copyright 2019 British Crown (Met Office) & Contributors.
# -----------------------------------------------------------------------------
set -eu
set -o pipefail

for util in git docker zip; do
    if ! "${util}" --version 1>'/dev/null'; then
        echo "Sorry, this script requires '${util}'." >&2
        exit 1
    fi
done

if [[ $# != 1 ]]; then
    echo "Usage: $(basename "$0") JULES_SOURCE" >&2
    exit 1
fi
JULES_SOURCE="$1"
#JULES_TEST_SOURCE="$2"

# Work in a temporary space
HERED="$(cd "$(dirname "$0")/.." && pwd)"
ORIGD="${PWD}"
WORKD="$(mktemp -d)"
pushd "${WORKD}"  # "${ORIGD}" => "${WORKD}"

# Build JULES executable
# -u ... As current user
# -v ... Mount the JULES source
# -v ... Inject a lambda.cfg build configuration file
# -v ... Build in current working directory
IMAGE_ENV='matthewrmshin/lambda-gfortran-fcm-make-netcdf'
docker run --rm \
    -u "$(id -u):$(id -g)" \
    -v "${JULES_SOURCE}:/opt/jules" \
    -v "${HERED}/etc/fcm-make/platform/lambda.cfg:/opt/jules/etc/fcm-make/platform/lambda.cfg" \
    -v "${PWD}:/tmp/jules-build" \
    "${IMAGE_ENV}" \
    env JULES_PLATFORM='lambda' \
    fcm make -C '/tmp/jules-build' -f '/opt/jules/etc/fcm-make/make.cfg' \
    'build.target=jules.exe'

# Prepare the package
# - Make sure shared object libraries are in place
mkdir -p 'package/bin' 'package/lib'
cp -p 'build/bin/jules.exe' 'package/bin/'
docker run --rm -u "$(id -u):$(id -g)" -v "${PWD}/package/lib:/tmp/package/lib" \
    "${IMAGE_ENV}" \
    bash -c 'cp -p /var/task/lib/*.so* /tmp/package/lib/'
cp -pr "${HERED}/task/"* 'package/'

# Test the package
#docker run --rm -u "$(id -u):$(id -g)" -v "${PWD}/package:/var/task" \
#    'lambci/lambda:python3.7' 'index.handler'

# Create the package zip file
pushd 'package'  # "${WORKD}" => "${WORKD}/package"
zip "${ORIGD}/lambda-jules.zip" 'index.py' 'bin/'* 'lib/'*
popd  # "${WORKD}/package" => "${WORKD}"

popd  # "${WORKD}" => "${ORIGD}"
rm -fr "${WORKD}"
#docker rmi "${IMAGE_ENV}"

exit
